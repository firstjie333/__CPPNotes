## 条款01：视C++为一个语言联邦

C++可视为：

- C：以C为基础。
- 面向对象的C++：添加面向对象特性。
- 模板C++：泛型编程概念，使用模板。
- STL：使用STL的容器、迭代器、算法、及函数对象。

四者的集合。



## 条款02：尽量以const、enum、inline替换 #define

对于单纯常量，尽量以const对象或enums枚举来代替#define。
对于函数宏，用inline函数代替#define（define是死板的替换，容易产生传递计算式类似累加多次的问题）

1. define在编译之前就被预处理器替换了，一旦被定义，在气候所有的编译过程中都有效，所以没有作用域的概念

2. 比如#define PI  3.1415926  由于预处理器的存在，PI可能没有进入记号笔，后面如果编译出错可能会看到3.1415926  ，然后对比别人来说，并不清楚3.1415926 为何物



## 条款03：尽可能使用const

详细看const.md 

还是再多记一下 迭代器的实现是以指针为基础的，其实：迭代器等于与T* 

```cpp
const iter == T* const 

const_iterator == const T*

```

### 条款04：确定对象被使用前已先被初始化

- 确定对象在使用前已经初始化，避免一些难以预测的问题。
- 为内置类型手动做初始化，C++不保证初始化它们。
- ==C++ 规定，对象的成员变量初始化动作发生在进入构造函数本体之前==
- ==1. 构造函数使用成员初始化列表来赋值，2. 而不是在构造函数里去赋值（会导致赋值两次，浪费了），3. 列表的排列次序保持和class中声明次序一致。4. 初始化列表中成员变量的实参，是拿去作为各个成员变的构造函数的实参==
- 对于一些可能在被别的类直接调用其成员函数、值的类，最好改为暴露一个返回其类对象的引用的函数的形式，而不是暴露其类对象本身，这可以保证在函数内完成初始化，避免被调用时还没有初始化

### 条款05：了解C++默默编写并调用哪些函数

1. 默认构造函数、析构函数、copy函数和copy assignment 运算法

2. 所以编译器自动产生的函数都是public的

3. 如果想组织copy 或者 copy assign ，则需要我们自己显示的声明其为private的，那么外面就不可调用了。 而boost也提供了这样一个基类，boost::nnoncopyable



## 条款06： 不可拷贝类

#### 方法1： 使用 `boost::noncopyable

```cpp
class Matrix : boost::noncopyable
{
    // 类实现
}
```

#### 方法2： 声明拷贝函数为私有，其实也就是boost的做法

```cpp
template<typename _T>
class Matrix 
{
private:
    Matrix(const Matrix<_T>&);
    Matrix<_T>& operator = (const Matrix<_T>&);
}
```

#### 方法2： C++ 11 下使用 delete 关键字

```cpp
template<typename _T>
class Matrix 
{
public:
    Matrix(const Matrix<_T>&) = delete;
    Matrix<_T>& operator = (const Matrix<_T>&) = delete;
}
```

## 条款07：为多态基类声明虚析构函数

- 如果一个基类可能有多态子类，那么就该声明一个虚析构函数。
- 如果一个类有任何虚函数，那么它就应该有虚析构函数。
- 如果一个类不被用来做基类，那么就不该声明虚析构函数。会使得对象的体积增大，因为需要维护一个虚函数表之类的。。。。



## 条款08：别让异常逃离析构函数

- ==析构函数不要抛出异常，==如果析构函数中调用的函数可能抛出异常，析构函数应该捕捉并记录下来然后吞掉他（不传播）或结束程序。

- 同时最好提供一个普通函数用来供用户执行可能异常的该操作。

- ==在构造函数和析构函数中不要去调用虚函数==，因为子类在构造/析构时，会调用父类的构造/析构函数，此时其中的虚函数是调用父类的实现，但这是父类的虚函数可能是纯虚函数，即使不是，也可能不符合你想要的目的（是父类的结果不是子类的结果）。
  如果想调用父类的构造函数来做一些事情，替换做法是：在子类调用父类构造函数时，向上传递一个值给父类的构造函数。

  

## 条款10：令 operator= 返回一个*this 引用

赋值操作符要反回一个 *this 的引用，如：

```cpp
TheClass& operator=(const TheClass& rhs) {
    ...
    return *this;
}
```



## 条款12：复制对象时勿忘其每一个成分

- 如果自己写copy ，需要保证所有的变量都被copy。 
- 如果有一个子类，写子类的copy函数时，也需要确保其继承自父类的所有变量都被正确的拷贝
- Copy函数和copy assign 看似代码类似，但不要用一个调用另一个，好的做法是建立一个private的成员函数来做这件事，然后两个构造函数都调用该成员函数。 通常命名该方法为init 



-----

## 一些不太深入了解的概念

- 记号表
- operator 
- mutable
- 单例
- 抽象class 