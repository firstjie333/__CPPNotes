https://www.jianshu.com/p/4661bd7b7593 

# 资源管理

所谓资源管理，不仅仅包括内存管理。还有诸如：互斥锁、文件描述符、数据库连接器。。。

### 条款13：以对象管理资源

书籍： 为了确保一个对象在初始化后能够最终有效被delete，最好使用shared_ptr和auto_ptr，而前者更好，因为是基于引用计数机制，可以在复制时保持两个指针都指向同一对象，且只有两个指针都销毁时才delete，而auto_ptr只会保证一个指针有效，在复制时，原指针会指向null。

- shared_ptr 以引用计数
- auto_ptr: 所管理的对象至多只有一个指针指向他，所以通过copy 或者 copy assign后，原来的auto_ptr变指向了null

==智能指针能够做到在退出作用域时——不管事正常流程离开，还是因为异常离开——总调用delete来析构对上动态分配的对象。==

```cpp
int main()
{
  auto_ptr<class_need_resource> p1(new class_need_resource);
  auto_ptr<demo_class> p2(factory.create());
} //离开作用域，p1,p2自动析构从而释放内存等资源

```



auto_ptr构造函数接受new操作符或者对象工厂创建出的对象指针作为参数，从而代理了原生指针。虽然它是一个对象，==但因重载了operator *和operator->，其行为非常类似指针，可以把它用在大多数普通指针可用的地方==。当退出作用域是，C++语言会保证auto_ptr对象销毁，调用auto_ptr的析构函数，进而使用delete操作符删除原始指针释放资源。==auto_ptr是标准C++库提供的。==

**boost库提供了六种智能指针，包括scoped_ptr、scoped_array、shared_ptr、shared_array、weak_ptr和intrusive_ptr，从各个方面增强std::auto_ptr，且异常安全**。

```cpp
scoped_ptr：用于处理单个对象的唯一所有权，与std::auto_ptr不同的是，scoped_ptr可以被复制。 

scoped_array：与scope_ptr类似，用于处理数组。 

shared_ptr：允许共享对象所有权。 

shared_array：允许共享数组所有权。

```



## ==RAII：Resoure Acquisition is initialization==

”资源取得的时机便是初始化的开始“

我的理解：RAII的观念要一直拥有，即你创建了对象，在用完后记得销毁，通常书籍建议用这些个智能指针来帮助我们实现。其核心思想也就说 （1）获得资源后我把他立刻放进管理对象中 （2）同时保证运用析构函数确保资源的释放







### 条款14：在RAII  资源管理类中小心copying行为

如果对想要自行管理delete（或其他类似行为如上锁/解锁）的类处理复制问题，有以下方案，先创建自己的资源管理类，然后可选择：

- **禁止复制**， 类似auto_ptr
- 对复制的**资源做引用计数（**声明为shared_ptr），shared_ptr支持初始化时自定义删除函数（auto_ptr不支持，总是执行delete）
- 在资源管理类中提供对原始资源的访问, **类似于智能指针中的get方法** 。



### ==条款16：成对使用new和delete时要采取相同形式==

new 对应 delete。
new a[4] 对应 delete [] a。
两者的使用必须对应。对于数组，不建议使用typedef行为，这会让使用者不记得去delete []。对于这种情况，建议使用string或者vector。



当使用new 有两件事发生，第一，内存被分出来了(operator new ) 第二，针对此内存会有一个或多个构造函数被调用。

当使用delete 也有两件事发生，第一，针对此内存有一个或者多个析构函数被调用，第二，该快内存被释放



### 条款17：以独立语句将newed对象置入智能指针

如果有函数参数接收智能指针对象，那么该智能指针对象一定要在调用该函数前用独立语句去创建，否则在创建所指对象和用该对象绑定智能指针两个操作之间，可能插入一些操作（由于C++的独特性），这时候如果出异常，那么会造成创建的对象还没来得及用智能指针修饰，也就无法被自动回收了。





# 设计与声明

### 条款18：让接口容易被正确使用，不易被误用（额 自己慢慢理解把）

### 条款19：设计class犹如设计type

### 条款20：宁以传递const引用替换传递值

- 尽量用 常量引用类型 来作为函数的参数类型，这通常比较高效，也可以解决基类参数类型被赋值子类时引起的内容切割问题。
- ==但对于内置类型和STL的迭代器与函数对象，通常编译器会对其专门优化，直接传值类型往往比较恰当。==

### 条款21：必须返回对象时，别妄想返回其引用

虽然函数参数最好用引用值，但函数返回值却不要随便去用引用，这回造成很多问题，比如引用的对象在函数结束后即被销毁，或是需要付出很多成本和代码来保证其不被销毁且不重复

- 绝对不要返回pointer或者reference指向一个local stack对象
- 也不要返回reference 指向一个heap-allocated对象，用指针

### 条款22：将成员变量声明为private

也就是说外部不要直接访问类的成员变量。好处：保证了封装性，保证调用都是用方法 等等一些列好处

### 条款23：宁以非成员、非友元替换成员函数

- 其实也是为了尽量提高封装性，毕竟如果是成员函数就可以访问成员变量了。这种函数位于函数之外，不能访问类的private成员变量和函数，保证了封装性（没有增加可以看到内部数据的函数量）
- 这些函数只要位于同一个命名空间内，就可以被拆分为多个不同的头文件，客户可以按需引入头文件来获得这些函数，而类是无法拆分的（子类继承与此需求不同），因此这种做法有更好的扩充性。类似于自己代码中的algohelper 或者painthelper

### 条款25：考虑写出一个不抛异常的swap函数

- 常规的swap是简单全复制三次对象进行交换（包括temp对象），如果效率足够就用常规版。
- 如果效率不够，那么给你的类提供一个成员函数swap，用来对那些复制效率低的成员变量（通常是指针）做交换。然后，提供一个非成员函数的swap来调用这个成员函数，供别人调用置换。
- 对于类（非模板），为标准std::swap提供一个特定版本（swap是模板函数，可以特化）。在使用swap时，记得 using std::swap，让编译器可以获取到标准swap或特化版本。编译器会自行从所有可能性中选择最优版本

