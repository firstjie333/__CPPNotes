https://www.jianshu.com/p/4661bd7b7593 

# 实现

### 条款26：尽可能延后变量定义式的出现时间

尽可能延后变量定义式的出现，

- 既包括延后构造它，保证只有真正使用才构造；

- 也包括只有到赋值时才构造它，避免默认构造函数无畏调用。

    

    对于循环操作，在循环前还是中进行构造，取决于赋值操作与构造+析构操作的成本对比。

- 方案1：循环前：1个构造函数+1个析构函数+n个赋值操作
- 方案2：循环后：n个构造函数+n个析构函数

```cpp
// method 1: 
int a
for i in n
{
	a = i;
}

// method 2: 
for i in n
{
 int a = i
}
```



通常只有当赋值成本小于 构造+析构成本是，选择方案1，否则选择方案2

==怎么知道哪种消耗成本大呢？==

### 条款27：尽量少做转型操作

1. 尽量避免使用转型cast，特别是注重效率的代码中避免用dynamic_casts。如果一定要用，试着考虑无需转型的替代设计，例如为基类添加一个什么也不做的衍生类使用的函数，避免在使用时需要将基类指针转型为子类指针。
    如果一定要转型，试着将其隐藏于某个函数后，客户调用该函数而无需自己用转型。
2. 宁可使用C++新式转型(4中cast )，也不用用C的旧式，因为新式的更容易被注意到，而且各自用途专一。
3. 绝对必须避免的是一连串的dynamic_cast



**四种强制转换**

**1、const_cast ：**去掉类型的const或volatile属性

**2、static_cast：**类似于C风格的强制转换。无条件转换，静态类型转换。用于：

　　1. 基类和子类之间转换：其中子类指针转换成父类指针是安全的;但父类指针转换成子类指针是不安全的。(基类和子类之间的动态类型转换建议用dynamic_cast)

　　2. 基本数据类型转换。enum, struct, int, char, float等。static_cast不能进行无关类型(如非基类和子类)指针之间的转换。

　　==3. 把空指针转换成目标类型的空指针。==

　　4. 把任何类型的表达式转换成void类型。

　　==5. static_cast不能去掉类型的const、volitale属性(用const_cast)。==

    ```cpp
int n = 6;
double d = static_castdouble>(n); // 基本类型转换
int *pn = &n;
double *d = static_cast<double *>(&n)//无关类型指针转换，编译错误
void *p = static_cast<void *>(pn); //任意类型转换成void类型
    ```



**3、dynamic_cast：**有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：

　　1. 安全的基类和子类之间转换。

　　2. 必须要有虚函数。

　　3. 相同基类不同子类之间的交叉转换。但结果是NULL。

**总 结**

- 去const属性用const_cast。　　
- 基本类型转换用static_cast。　　
- 多态类之间的类型转换用dynamic_cast（基类和子类之间的转换）　　
- 不同类型的指针类型转换用reinterpreter_cast

### 条款28：避免返回handles指向对象内部成分

==避免让外部可见的成员函数返回handles（包括引用、指针、迭代器）指向对象内部（更隐私的成员变量或函数）==，如果必须 那么加const。

### 条款29：为异常安全而努力是值得的

- 不泄露任何资源
- 不允许数据败坏

个人的理解就是一定要考虑各种异常情况的出现，并且确保资源能都在即使发生异常的时候也被释放，那些数据的状态也应该回到初始的状态，资源记得都要回收



### 条款30：透彻了解inline的里里外外

1. inline的意义是 对此函数的每个调用 ，都以函数本体的方式替换他
2. inline只是对编译器 让他进行替换的一个申请
3. 编译器有权拒绝inline。理由是：
    1. 函数太复杂
    2. 有virtual函数的调用
    3. 大部分编译器如果不能inline 某些函数，会给出警告的
4. 由于编译器要将函数调用替换为函数本体，所以必须知道那个函数长什么样子。因此通常inline函数都放在头文件里
  

### 条款31：将文件间的编译依存关系降至最低

1. 为了增加编译速度，应该减少类文件之间的相互依存性（include），但是类内又常常使用到其他类，不得不相互依存，解决方案是：将类的声明和定义分开（不同的头文件），声明相互依存，而定义不相依存，这样当定义需要变更时，编译时不需要再因为依赖而全部编译。基于此构想的两个手段是Handle classes和Interface classes。
2. 或者使用interface class 



# 继承与面向对象设计

### 条款32：确定你的public继承是is-a关系

class B ： public A ： 每一个B对象就是一个A对象，使用与A身上的每一件事情，都适用B

### 条款33：避免遮掩继承而来的名称

名称查找的规则

1. 子类的同名函数，会覆盖基类的函数，即使参数不同，都会因为名字被覆盖了而看不到基类中的任一同名函数了
2. 如果又想要使用基类中被覆盖的同名函数，必须using A::func; 



### 条款34：区分接口继承和实现继承

1. 基类中的pure vistual 函数： 让子类只继承其接口，并且必须提供一份自己特例化的实现； 基类中也可以给出pure virtual的一份实现，但是需要想调用这份特丽华的实现，需要明确调用类型，即pb->A::func();

2. 基类中的virtual 函数： 让子类继承其接口，也继承一份实现。子类可以重新处理基类的实现，当然没有必要时也可以不处理直接使用A的缺省实现
3. 基类中的non-virtual函数：表示子类要继承基类的接口+实现，并且不可改变。因此最好不要出现33中的名字覆盖问题



### 条款35：考虑虚函数以外的其他选择

虚函数（本质是希望子类的实现不同）的替代方案

- ==用public的非虚函数来调用private的虚函数具体实现，非虚函数必须为子类继承且不得更改，所以它决定了何时调用以及调用前后的处理；虚函数实现可以在子类中覆写，从而实现多态。==
- 将虚函数替换为函数指针成员变量，这样可以对同一种子类对象赋予不同的函数实现，或者在运行时更改某对象对应的函数实现（添加一个set函数）。
- ==用::function成员变量替换虚函数，从而允许包括函数指针在内的任何可调用物搭配一个兼容于需求的签名式。==
- 将虚函数也做成另一个继承体系类，然后在调用其的类中添加一个指针来指向其对象。





### 条款36：绝不重新定义继承而来的非虚函数

### 条款37：绝不重新定义继承而来的缺省参数值

### 条款38：通过复合表示 has-a 或者“根据某物实现出”的关系

注意 has-a 和 is-a 的区分。如果是 is-a 的关系，可以用继承，但如果是 has-a 的关系，应该将一个类作为另一个类的成员变量来使用，以利用该类的能力，而不是去以继承它的方式使用。

### 条款39：明智而审慎地使用private继承

Private继承意味着: 子类对象是根据基类对象实现而得到的，除此之外再无其他意义。==只是一种基类，而没有实际意义==

### 条款40：明智而审慎地使用多重继承

1. 如果两个base class 都有相同名称的函数，容易产生歧义，在调用是一定要明确指出调用哪个函数，pc->B::func();
2. 会存在砖石继承的情况，所以可能会需要virtual 继承
3. virtual的基础 会导致，大小，速度，初始化等体积的增加，所以最好不用
4. 看看我们的代码里，哪里用了多重建继承，obs、point

