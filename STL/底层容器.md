# vector

vector是我们用到最多的数据结构，其底层数据结构是**数组**，由于数组的特点，vector也具有以下特性：
1、O(1)时间的快速访问；
2、顺序存储，所以插入到非尾结点位置所需时间复杂度为O(n)，删除也一样；
3、**扩容规则：** 
	当我们新建一个vector的时候，会首先分配给他一片连续的内存空间，如`std::vector<int> vec`，当通过push_back向其中增加元素时，如果初始分配空间已满，就会引起vector扩容，其扩容规则在gcc下以2倍方式完成：

- 首先重新申请一个2倍大的内存空间；
- 然后将原空间的内容拷贝过来；
- 最后将原空间内容进行释放，将内存交还给操作系统；



# map与multimap

map与multimap是STL中的**关联容器**、提供一对一key-value的数据处理能力； map与multimap的区别在于，multimap允许关键字重复，而map不允许重复。

这两个关联容器的底层数据结构均为**红黑树**，关于红黑树的理解可以参考[教你透彻了解红黑树](https://link.jianshu.com/?t=https%3A%2F%2Fgithub.com%2Fjulycoding%2FThe-Art-Of-Programming-By-July%2Fblob%2Fmaster%2Febook%2Fzh%2F03.01.md)一文。根据红黑树的原理，map与multimap可以实现**O(lgn)**的查找，插入和删除。

而且以Key排序 



# unordered_map 与unordered_multimap

unordered_map与unordered_multimap 对比2.1中的两种map在于其2.1中的两个容器实现了以key为序排列，也就是说map与multimap为**有序的**。

而unordered_map与unordered_multimap中key为无序排列，其底层实现为**hash table**，因此其查找时间复杂度理论上达到了**O(n)**，之所以说理论上是因为在理想无碰撞的情况下，而真实情况未必如此。







set系与map系的区别在于map中存储的是<key-value>，而set可以理解为关键字即值，即只保存关键字的容器。

#  set & multiset

- set与multiset有序存储元素，这两种容器的底层实现与map一样都是**红黑树**，所以能实现O(lgn)的查找，插入，删除操作。

- set与multiset的区别在于是否允许重复；

# unordered_set & unordered_multiset

与unordered_map & unordered_multimap相同，其底层实现为**hash table**；

# priority_queue

优先级队列相当于一个**有权值**的单向队列queue，在这个队列中，所有元素是按照优先级排列的。

priority_queue根据**堆**的处理规则来调整元素之间的位置，关于堆的原理，可以参考[堆](https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fchangyuanchn%2Farticle%2Fdetails%2F14564403)；

根据堆的特性，优先级队列实现了取出最大最小元素时间复杂度为O(1),对于插入和删除，其最坏情况为O(lgn)。



# list

底层数据结构为**双向链表**，特点是支持快速的增删。

# queue

为单向队列，为先入先出原则。

# deque

为双向队列，其对比queue可以实现在头尾两端高效的插入和删除操作



----

STL map和set的使用虽不复杂，但也有一些不易理解的地方，如：
\# 为何map和set的插入删除效率比用其他序列容器高？
\# 为何每次insert之后，以前保存的iterator不会失效？
\# 为何map和set不能像vector一样有个reserve函数来预分配数据？
\# 当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？



### 为何map和set的插入删除效率比用其他序列容器高？

大部分人说，很简单，因为对于关联容器来说，不需要做内存拷贝和内存移动。说对了，确实如此。map和set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。结构图可能如下：

​     A
​    / /
​    B  C
​    / / / /
   D E F G

因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点就OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。

### 为何每次insert之后，以前保存的iterator不会失效？

看见了上面答案的解释，你应该已经可以很容易解释这个问题**。iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。**  ==相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。==



# 当数据元素增多时（10000和20000个比较），map和set的插入和搜索速度变化如何？

如果你知道log2的关系你应该就彻底了解这个答案。在map和set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。