# C++中如何定义动态数组

https://blog.csdn.net/bzhxuexi/article/details/17230073

首先：为什么需要动态定义数组呢？
 这是因为，很多情况下，在预编译过程阶段，数组的长度是不能预先知道的，必须在程序运行时动态的给出
 但是问题是，c++要求定义数组时，必须明确给定数组的大小，要不然编译通不过 

 如： int Array[5];正确

​    int i=5;
​    int Array[i]; 错误 因为在编译阶段，编译器并不知道 i 的值是多少

  那么，我们该如何解决定义长度未知的数组呢？
  答案是：new 动态定义数组 

  因为new 就是用来动态开辟空间的，所以当然可以用来开辟一个数组空间
  
  这样，下面的语句：
  int size=50;
  int *p=new int[size]; 是正确的
 
  但是二维动态数组能不能也这样定义呢
  
 int size=50,Column=50;
 int (*p)[Column]=new int [size][Column]

 这样的语句，编译器通不过，为什么呢？
 首先 new int[size][Column] 就是动态生成时确定的，所以它没有错
 那么就是 int（*p）[Column]，这句有问题了，这句为什么不对呢， 那是因为，这是一个定义语句，而定义语句先经过编译器进行编译，当编译器运行到此处时，发现Column 不是常数，因此不能通过编译。 而之所以编译器认为Column 不是常数，是因为编译阶段，编译器起的作用是查语法错误，和预分配空间，它并不执行程序，因此，没有执行那个赋值语句（只是对这个语句检查错误，和分配空间），因此编译阶段，它将认为column 是个变量。所以上面的二维数组定义是错误的， 它不能通过编译。

 改成这样：
 int size=50
 int (*p)[50]=new int [size][50]
 便正确了。

  由此可见，这种动态分配数组，仅对一维数组空间是真正动态分配的。
  但是如何真正的动态分配二维数组呢，即如果Column 也不能预先知道的话，该如何处理呢？
  
  上面的动态分配已经不能满足我们的要求，因为上面动态分配只对一维数组是真正动态的，对二维数组的话，必须编译之前预先知道二维数组每一列的长度，而这个长度在很多情况下是不能预先知道的，所以我们得结合其他方法来解决这个问题。
  
  既然一维是真正的动态分配的话，那我们利用这一特性定义一个指针数组。
  
  int **p= new int*[size];//定义指针数组 
  int *p[5];// 假若知道二维数组的行数为5

  然后对指针数组中的每一个指针分配一个一维数组空间，这样便动态定义了二维数组
 
  事实上，我认为指针数组的主要用途，就在于动态定义多维数组
  
  for(int i=0;i<size;i++)
  {
   p[i]=new int[Column];
  }
  
  运行完毕后，一个二维数组便被动态的成功建立

\-----------------------------------

 

例子：

 

  size =6;

 

  column =5

 

  int **p=new int*[size];

 

  for(int i=0;i<size;i++)
  {
   p[i]=new int[Column];
  }

 

 

 

所生成的动态数组如下图所示：