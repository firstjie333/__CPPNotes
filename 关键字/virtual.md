​    虚函数和非虚函数的唯一区别——当使用指针或引用调用虚函数时，则由编译器产生的代码将在运行时根据对象的动态类型再确定到底运行该虚函数的哪一个版本。

### 4.2.1 虚函数的限制

1. 构造函数不能是虚函数（注：析构函数、拷贝/移动赋值运算符及其他运算符重载函数都可以是虚函数）；
2. 静态成员函数不能是虚函数；
3. 关键字virtual只能出现在类内部的声明语句之前，而不能用于类外部的函数定义；
4. 如果基类把某个成员函数声明成虚函数，则该函数在派生类中的覆盖（重写）版本隐式地也是虚函数；
5. 不管虚函数是否被调用到了，我们都必须为每一个虚函数都提供定义——因为编译器无法确定虚函数的哪个版本在运行时会被使用。

### 4.2.2 派生类覆盖基类虚函数

#### 4.2.2.1 派生类覆盖虚函数的要求

​    如果需要在派生类中定义一个覆盖基类中某个虚函数的成员函数，则它必须满足以下条件：

它的函数名称和形参列表必须与被它覆盖的基类虚函数完全一致（注：包括this指针的const属性、noexcept异常说明等也需要保持一致）；它的返回类型： 当基类的虚函数返回类型是基类本身的指针或引用时，且从派生类到基类的隐式类型转换是可访问的，那么派生类的覆盖版本的返回类型可以是派生类的指针或引用；否则，派生类中的覆盖版本的返回类型也必须与基类相应的虚函数的返回类型完全一致。

注1：只有虚函数才存在“覆盖”一说；

注2：在派生类中也可以定义函数原型和基类中的某个非虚函数完全一样的特有成员函数（但这并不是对该基类非虚函数的“覆盖”），**因此在派生类中定义和基类中某个成员函数原型完全一样的特有成员函数并非只是虚函数的“权利”——因为基类和派生类中的this隐式形参类型是不一样的；**







设置虚函数须注意： 
1：只有类的成员函数才能说明为虚函数； 
2：静态成员函数不能是虚函数； 
3：内联函数不能为虚函数； 
4：构造函数不能是虚函数； 
5：析构函数可以是虚函数，而且通常声明为虚函数。